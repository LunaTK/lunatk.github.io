{"pages":[],"posts":[{"title":"img 태그와 부모 태그의 높이가 왜 다를까?","text":"블로그에 URL 미리보기 기능을 만들던 도중 img 태그와 부모 태그의 높이가 다른 버그가 발생하였다. 빨간 부분 만큼 높이 차이가 발생 해당 HTML과 CSS는 대략 다음과 같다 html1234567891011&lt;div&gt; &lt;div class=\"og-image\"&gt; &lt;a&gt; &lt;img src=\"~~\"&gt; &lt;/a&gt; &lt;/div&gt; &lt;div&gt; &lt;!-- 웹사이트 요약 텍스트가 들어가는 부분 --&gt; &lt;/div&gt;&lt;div&gt; css1234567.og-image { background: red;}img { height: 120px;} 하지만 이상하게도 og-image 와 img 의 높이가 일치하지 않았다. 위는 비슷하게 구현해 본 코드이다.코드만 보면 img와 og-image의 높이가 같을 것 같지만, 실제 result를 보면 높이가 다르다. img 태그의 사이즈 (596.33 x 200) div.og-image 태그의 사이즈 (596.33 x 206) img를 a로 감싸서 그런가 a 태그를 제거해 보았지만, 여전히 오차가 있었다.혹시나 해서 og-image 의 높이를 직접 120px로 고정해 보니 img와 높이가 일치하긴 했다.하지만 responsive design을 적용 할 계획이라 높이를 고정시키지 않고 해결 할 필요가 있었다. 개발자 도구를 켜놓고 height, flex, max-height 등등 의심이 가는 원인을 다 건드려 보다, display옵션을 바꿔보던 중 버그가 해결되었다. 어떻게 해결 되었나 보니, img 태그의 display 값을 block 으로 바꾸니 해결되었던 것이었다. 문제를 해결한 JSFiddle 마치며img 태그의 display 속성 기본 값은 inline-block 이라고 한다 (그래서 width, height 값을 줄 수 있다고 한다). 근데 웃긴건 그렇다고 해서 다른 inline-block 속성을 준 태그에서 저런 문제가 발생하지는 않는다.(아마 img 태그는 좀 특별한 케이스의 inline-block인것 같다.) img 태그에서만 저런 문제가 발생하는것 같은데, 섬세한 관심이 필요한 친구인 것 같다. 기회가 되면 아래 링크의 img 태그 스펙을 자세히 살펴봐야 할것 같다. &lt;img&gt;: The Image Embed elementThe HTML img element embeds an image into the document. 사실 URL 미리보기가 잘 작동하는거 자랑할려고 괜히 한번 링크를 걸어보았다. 😏👍🏻","link":"/2019/10/28/20191028-html-img-parent-height/"},{"title":"webpack:// 경로는 무엇일까?","text":"학교 아이캠퍼스 소스를 보다, 웹사이트 리소스에서 신기한걸 발견했다. 아이캠퍼스가 리액트로 만들어졌는데, 개발 모드로 열려있는지 소스가 다 보이는 것이었다.(아마 webpack-dev-server로 열어 놓은 것 같다) 평소 리액트 개발을 할 때 개발자 도구에서 원본 파일로 디버깅이 되는걸 당연시 했었는데, 사용자 입장에서 원본 파일이 보이니 갑자기 이상한 점이 눈에 띄었다. 파일 출처가 webpack:// 인데, 이게 뭐지?다른 파일들은 모두 URL 주소가 출처로 되어있었다. 그런데 저 리액트 앱 원본 코드들은(심지어 node_modules 폴더도 있다) 출처가 webpack://으로 되어있었다. 도대체 어떻게 가져왔길래 저렇게 표시가 되는지 원리가 궁금해 찾아보게 되었다. 여러가지 시도1. 일반 js 파일처럼 HTTP 요청을 통해 가져 올 것이다개발자 도구에서 일반 js 파일과 똑같이 보이니, 가져오는 방법도 일반 js 파일과 똑같을 것이란 생각이 먼저 들었다. 웹 사이트 내에서 불러오는 모든 리소스는 개발자 도구의 Network 탭에서 확인할 수 있다. 페이지 로딩이 다 끝난 후 확인 해 보니, webpack:// 디렉토리에서 확인할 수 있었던 수많은 js 파일이 단 하나도 없었다. 그래서 일단 webpack://이 뭔지 구글링을 해 보기로 하였다. https://github.com/angular/angular-cli/issues/11058 정확히 나와 똑같은 생각을 한 질문이 있었다. 해당 질문에서 얻은 내용을 정리해 보면 다음과 같다. webpack source map 에 쓰이는 커스텀 프로토콜이다 (나중에 알았지만 커스텀 프로토콜이 아니었다… 이 답변때문에 엄청 헷갈렸다) webpack-dev-server 와 관련이 있다 2. Source Map에 정보가 있을것이다위 답변을 통해 Source Map 과 큰 관련이 있다는 사실을 알 수 있었다. 그래서 우선 Source Map 이 무엇인지 검색해 보았다. 클라이언트측 코드를 결합하거나 최소화하거나 컴파일한 후에도 읽을 수 있고 디버그할 수 있게 합니다.소스 맵을 사용하여 소스 코드를 컴파일된 코드에 매핑합니다 정리하자면, webpack과 같이 원본 코드를 압축, 변형하는 경우 변형된 코드를 원본 소스코드를 보며 디버깅 할 수 있도록 변환된 파일을 원본 파일에 맵핑해 주는 파일이라고 한다. 맵핑할 js 파일 하단에 //# sourceMappingURL=http://example.com/sourcemap.map 과 같이 맵핑 파일의 URL을 넣어주면 자동으로 디버깅시 원본 소스코드를 보여준다고 한다. 위 사진처럼, Source Map detected 란 문구와 함께 맨 아랫줄에 주석으로 source map의 URL이 있는걸 확인할 수 있었다. 해당 URL로 들어가보니, 정신이 혼미해지는 source map 파일을 확인할 수 있었다. 현재 사용되는 소스맵은 스펙은 V3 버전인데, 다음과 같은 구조를 가진다고 한다. 12345678{ version : 3, file: \"out.js\", // source map 을 해줄 컴파일 된 js 파일 sourceRoot : \"\", // 원본 소스파일들 앞에 붙여줄 공통 경로 sources: [\"foo.js\", \"bar.js\"], // output file을 만드는데 쓰인 js 파일들 names: [\"src\", \"maps\", \"are\", \"fun\"], // javascript 안에 있는 함수, 변수 등의 이름 mappings: \"AAgBC,SAAQ,CAAEA\" // base64로 인코딩 된 실제 맵핑 테이블} 위 스펙에 따르면, webpack:///./public/javascripts/dummyl18nResource.js?1e80같은게 실제 파일이 있는 URL이어야 한다. 근데 경로에 . 이 들어가 있질 않나, webpack:// 같은걸로 시작하는 등 일반적인 URL 모양이 아니었다. 그래도 스펙이 그렇다 하니 일단 해당 URL로 접근 해 보았다. 역시나 안됬지만, 이건 뭐 되는게 더 이상했을 것 같다. 3. webpack 프로토콜이 있을것이다우리가 아는 일반적인 URL은 프로토콜://도메인:포트로 생겼다. 일단 webpack://의 생김새가 URL 처럼 생겼고, 실제로 그렇게 쓰여야 하니, 혹시 사이트 내에서 webpack이라는 커스텀 프로토콜을 정의한게 아닌가 생각이 들었다. 요새 웹은 정말 희안한 기능들이 많아서(ex. ws://), 충분히 가능할거라 생각하였다. 그리고 진짜 커스텀 프로토콜을 정의하는 기능이 있긴 있었다!! 하지만 깃허브 webpack, webpack-dev-server 저장소에서 검색을 해 봐도, 딱히 커스텀 프로토콜을 정의하는 부분을 찾을 수 없었다. 4. Source Map을 이용해 원본 소스코드를 다운해 보자개발자 도구에서 다른 사이트 Source Map이 보인다면 원본 소스코드를 다운할수 도 있다는건데, 이를 구현해놓은 코드가 없나 찾아보다 다음 포스팅을 발견했다. Extracting Javascript From SourceMaps 이분이 딱 내가 원하는 코드를 만들어서 github에 공개까지 해 놓으셨다 (denandz/sourcemapper) 그런데 Source Map 스펙에 따르면 분명 원본 파일을 다운받으려면 sources에 포함된 파일 하나당 한번의 HTTP 요청을 해야하는데, 위 소스코드에는 source map 파일을 받아오는 최초 한번의 HTTP 요청을 제외하고는 HTTP 요청이 없었다. 도대체 그럼 어떻게 원본 파일을 가져오는지 소스코드를 한번 다 읽어 보았다. 12345type sourceMap struct { Version int `json:\"version\"` Sources []string `json:\"sources\"` SourcesContent []string `json:\"sourcesContent\"`} 위 구조체가 sourceMap을 저장하는 구조체인데, sourcesContent 라는 처음보는 속성이 있었다. 구글링 해 보니, Source Map Revision 3 Proposal을 참고하라는 StackOverflow 게시글을 하나 찾을 수 있었다. 2019년 2월 19일에 추가된 스펙이었다. (그럼 그 이전에는 어떻게 소스맵을 제공했을까?) 하지만 스펙문서 설명이 너무 부실해서 저 내용만 봐서는 저게 정확히 무슨 기능인지 알기 어려웠다. 링크를 찾은 StackOverflow 게시글에 따르면, An optional list of source content, useful when the “source” can’t be hosted 아… 그러니까 선택적으로 Source Map 안에 Source Content, 즉 원본 소스코드를 넣을 수 있다는 말이었다… 원본 코드를 싹다 가지고 있어서인지, 저 소스맵 파일 하나의 용량이 20 메가바이트였다… 결론webpack:// 은 프로토콜이나 URL이 아니고, 그냥 웹팩이 임의로 파일 이름에 붙인 접두사 같은 것 이었다. 그리고 sources에 있는 파일 이름과 sourcesContent 에 있는 소스코드 내용이 순서대로 매칭되고, 실제 파일 내용을 sourcesContent에서 가져오더라도 sources 에 있는 파일 URL로부터 가져온것 처럼 개발자 도구에 표시가 되는 것이었다. 글로 정리하니 얼마 안되는 양이지만, 이걸 알아내는데 하루가 걸렸다. 소스맵이 W3C 표준은 아니라고 하는데, 왜 아닌지 알 것 같은 경험이었다😅","link":"/2019/10/21/20191021-what-is-webpack-path/"},{"title":"Rollup & Svelte 에서 PurgeCSS 사용하기","text":"외주 프로젝트용 Web Component 개발에 UI 라이브러리를 사용하니, 빌드된 컴포넌트 사이즈가 너무 큰 문제가 발생해 PurgeCSS를 이용해 최적화를 해 보기로 하였다. 개발 환경은 다음과 같았다. Front-End Framework : Svelte Module Bundler : Rollup.js UI Library : Bulma 디자인을 전달받기 전이라 우선 UI 라이브러리를 사용하여 개발을 진행하였다.Rollup은 자바스크립트 번들러이기 때문에, 기본적으로는 진짜 자바스크립트 파일밖에 번들링을 못한다.따라서 .svelte, .css 파일을 번들링 하기 위해서는 적절한 플러그인을 적용해 주어야 한다. 1. Rollup Plugin 추가rollup.config.js123456789101112131415import svelte from 'rollup-plugin-svelte';import postcss from 'rollup-plugin-postcss';// 몇가지 Plugin을 더 사용했지만, 생략export default { input: 'src/index.js', output: [ { file: `public/${pkg.module}`, 'format': 'es' }, { file: `public/${pkg.main}`, 'format': 'umd', name } ], plugins: [ svelte(), postcss() ]} rollup-plugin-svelte 를 통해 .svelte 파일을 로드하고, rollup-plugin-postcss 를 통해 .css 파일을 로드할 수 있게 설정하였다. 이제 svelte 파일의 script 부분에서 Bulma의 css 파일를 import 할 수 있다. 2. svelte 컴포넌트에서 css 파일 import 하기component.svelte12345&lt;script&gt; import 'bulma/css/bulma.css'; //생략&lt;/script&gt;// Svelte HTML 부분 이렇게 해서 만들어진 컴포넌트는 아래처럼 생겼다. Svelte와 Bulma를 이용한 스마트폰 검색 Web Component 그런데 문제가 생겼다. css 파일을 import 하면 이를 string으로 바꿔서 통째로 번들링 해버리기 때문에, 쓰지 않는 속성까지 다 포함되어 용량이 너무 컸던 것이었다. Web Component 치고는 무거운 결과물 요즘 웹사이트 하나 webpack으로 빌드하면 기본이 몇 MB 이니, 260kb 정도면 작다 생각할 수 있지만, 이건 웹 컴포넌트로 쓸꺼라 최대한 줄일 필요가 있었다. 그래서 사용하지 않는 css 속성을 제거해준다는 PurgeCSS라는 툴을 사용해 보기로 했다. (이름이 ㅎㄷㄷ 하다. CSS 숙청…😦) PurgeCSS우선 PostCSS는 Webpack, Gulp, Grunt, Rollup 등 그냥 아무데나 다 갖다 쓸 수있고, 심지어 그냥 Standalone 으로도 쓸 수 있는 툴이다. 나는 빌드환경을 Rollup으로 잡아놓았기 때문에, 공식 사이트에 나와있는 Rollup 가이드를 확인해 보았다. With Rollupundefined PurgeCSS With Rollup 이게 끝이다. 그냥 저 페이지에 저거밖에 없었다… 정보가 너무 빈약해서 Configuration을 살펴보았다. Options1234567891011{ content: Array&lt;string | RawContent&gt;, css: Array&lt;string | RawContent&gt;, extractors?: Array&lt;ExtractorsObj&gt;, whitelist?: Array&lt;string&gt;, whitelistPatterns?: Array&lt;RegExp&gt;, whitelistPatternsChildren?: Array&lt;RegExp&gt;, keyframes?: boolean, fontFace?: boolean, rejected?: boolean} 중요한 부분만 보자면 다음과 같았다. content : css 사용 여부를 확인할 파일 (ex. html, js) css : 숙청할 css 파일 extractors : content에서 css selector를 추출해 주는 친구 whitelist : 사용되지 않더라도 숙청하지 않을 css selector 목록 With Rollup 가이드를 보면, content로 html 파일을 사용하고 있다. .svelte 파일도 사용 가능한지 공식 문서를 확인해 보았다. PurgeCSS provides a default extractor that is working with all types of filesbut can be limited and not fit exactly the type of files or css framework that you are using. 확인해 보니 Default Extractor로도 모든 파일이 다 된다고 한다(우와 개쩐다). 하지만 좀더 정확히 하려면 Custom Extractor를 만들어 쓰라고 한다. langbamit/purgecss-from-html 이라는 누가 만들어 놓은 Svelte용 Extractor가 있었다. 결론부터 말하면 이거 안써도 똑같이 잘 되서 처음엔 썼지만 마지막 단계에서는 그냥 안쓰기로 하였다. 이제 PurgeCSS를 Rollup에 적용해 보았다. rollup.config.js1234567891011121314151617181920212223242526import svelte from 'rollup-plugin-svelte';import postcss from 'rollup-plugin-postcss';import purgecss from 'rollup-plugin-purgecss';import PurgeSvelte from \"purgecss-from-svelte\";// 몇가지 Plugin을 더 사용했지만, 생략export default { input: 'src/index.js', output: [ { file: `public/${pkg.module}`, 'format': 'es' }, { file: `public/${pkg.main}`, 'format': 'umd', name } ], plugins: [ svelte(), postcss(), purgecss({ content: [\"./src/**/*.svelte\"], extractors: [ { extractor: PurgeSvelte, extensions: [\"svelte\"] } ] }) ]} 여기서 한방에 되면 재미가 없으니, 바로 오류를 뿜어주는 Rollup… CssSyntaxError 라는 키워드로 구글링을 하다 다음 StackOverflow 게시글을 발견했다 CssSyntaxError (1:1) Unknown word &gt; 1 | // extracted by mini-css-extract-plugin · Issue #358 · webpack-contrib/mini-css-extract-pluginmode: &amp;#39;production&amp;#39;, devtool: &amp;#39;#source-map&amp;#39;, plugins: [ new webpack.DefinePlugin({ &amp;#39;process.env.NODE_ENV&amp;#39;: JSON.strin… you have multiple loader for css please check your configuration css loader를 여러개 설정해서 생기는 에러라고 한다. 그래서 postcss 플러그인을 빼고 purgecss만 남겨보았는데, 또 에러가 발생하면서 안되었다. 좀더 구글링을 하던중, 어느 외국회사 GitLab이 떴다…! (다음에 GitLab 쓸일이 있으면 조심해야겠다…) 운이 좋게도 그곳에서 해답을 얻을 수 있었다. PurgeCSS를 Rollup Plugin이 아니라 PostCSS의 Plugin으로 만들어 놓은게 있었다 (FullHuman/postcss-purgecss). 성공한 Rollup 설정은 다음과 같다. rollup.config.js12345678910111213141516171819202122232425262728293031import svelte from 'rollup-plugin-svelte';import postcss from 'rollup-plugin-postcss';import Purgecss from \"@fullhuman/postcss-purgecss\"import PurgeSvelte from \"purgecss-from-svelte\";// 몇가지 Plugin을 더 사용했지만, 생략const purgeCss = Purgecss({ content: [\"./src/**/*.svelte\"], extractors: [ { extractor: PurgeSvelte, extensions: [\"svelte\"] } ]});export default { input: 'src/index.js', output: [ { file: `public/${pkg.module}`, 'format': 'es' }, { file: `public/${pkg.main}`, 'format': 'umd', name } ], plugins: [ svelte(), postcss({ plugins: [ purgeCss ] }), ]} PurgeCSS 적용한 결과물 File Size 결과는 감동적이었다. 264kb 에서 46kb로 무려 83% 감소하였다…😭 PurgeCSS 적용한 결과물 그런데 위 사진처럼 폰트가 좀 이상하게 나왔다. 확인해 보니 아래 selector가 날라갔다. 아마 Bulma 라이브러리가 폰트를 모든 Element에 적용하기 위해 body 태그에 적용했는데, .svelte 파일 내에서 body태그를 직접적으로 사용하는 부분이 없어서 안쓴다고 판단되 삭제된것같다. `body` selector로 폰트가 적용되어있다 `body` selector가 삭제되었다 그래서 PurgeCSS 의 whitelist에 body를 추가해 주었다. Solutionrollup.config.js123456789101112131415161718192021222324252627import svelte from 'rollup-plugin-svelte';import postcss from 'rollup-plugin-postcss';import Purgecss from \"@fullhuman/postcss-purgecss\"// import PurgeSvelte from \"purgecss-from-svelte\";// purgecss-from-svelte 는 안써도 문제 없다// 몇가지 Plugin을 더 사용했지만, 생략const purgeCss = Purgecss({ content: [\"./src/**/*.svelte\"], whitelist: ['body'] // whitelist 추가});export default { input: 'src/index.js', output: [ { file: `public/${pkg.module}`, 'format': 'es' }, { file: `public/${pkg.main}`, 'format': 'umd', name } ], plugins: [ svelte(), postcss({ plugins: [ purgeCss ] }), ]} 폰트가 성공적으로 잘 적용되었다. 빌드된 모듈 용량은 거의 그대로였다.","link":"/2019/11/09/20191109-purgecss-with-rollup-and-svelte/"},{"title":"Node.js 에서 request 한글 깨짐 문제","text":"Node.js 에서 request 모듈을 사용하여 학교 홈페이지를 크롤링 하는 도중 한글이 깨지는 문제가 발생하였다. 한글 깨짐 현상 한국인으로서 담담하게 받아들일 수 있는 현상이다. 확인해보니, Node.js는 UTF-8을 기본 인코딩으로 사용하는데 학교 홈페이지는 EUC-KR을 사용해서 글자가 깨지는 것 같았다. 웹페이지 인코딩 확인 그래서 EUC-KR 디코딩을 하게 해 주었는데, 여전히 표시가 잘 안되었다. EUC-KR 처리 후 한글 깨짐 현상 원인그런데 이 占쏙옙 이라는 글자, 낯설지가 않은 사람들이 많을것이다… 문제를 해결하기에 앞서 왜 한글이 깨지면 저렇게 占쏙옙 이 미친듯이 반복되는지 궁금해 검색 해 보았다. 占쏙옙 의 정체 출처 : https://namu.wiki/w/占쏙옙 정리하자면 다음과 같다. EUC-KR로 표현된 데이터 UTF-8로 저장한다. 이때 UTF-8로 표현될 수 없는 문자는 모두 “표현 불가” 문자, 즉 � 로 치환된다. 이를 다시 EUC-KR로 취급하여 UTF-8로 변환하려 하면, 占쏙옙 이 된다. 이때문에 EUC-KR을 잘못 다루면 占쏙옙 파티를 볼 수 있게 되는 것이었다. 내가 겪은 문제는 아마 request 모듈에서 EUC-KR을 제대로 처리하지 않고 바로 UTF-8로 저장을 해서, 이미 � 으로 다 치환이 된 상태에서 EUC-KR 디코딩을 시도한게 원인인 것 같았다. 해결방법해결방법은 간단하다. request 모듈이 문자열 인코딩 처리를 안하게 해주면 된다. 12345678request({ url:\"http://icampus.ac.kr\" // 원하는 url값을 입력 ,encoding: null //해당 값을 null로 해주어야 제대로 iconv가 제대로 decode 해준다. } ,(err, res, body) =&gt; { // 생략 }}) 출처 : http://b1ix.net/322 야! 잘된다","link":"/2019/10/25/20191025-nodejs-request-encoding/"}],"tags":[{"name":"css","slug":"css","link":"/tags/css/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"rollup","slug":"rollup","link":"/tags/rollup/"},{"name":"svelte","slug":"svelte","link":"/tags/svelte/"},{"name":"node.js","slug":"node-js","link":"/tags/node-js/"}],"categories":[{"name":"Development","slug":"Development","link":"/categories/Development/"},{"name":"Web","slug":"Development/Web","link":"/categories/Development/Web/"},{"name":"Node.js","slug":"Development/Node-js","link":"/categories/Development/Node-js/"}]}