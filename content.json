{"pages":[],"posts":[{"title":"webpack:// 경로는 무엇일까?","text":"학교 아이캠퍼스 소스를 보다, 웹사이트 리소스에서 신기한걸 발견했다. 아이캠퍼스가 리액트로 만들어졌는데, 개발 모드로 열려있는지 소스가 다 보이는 것이었다.(아마 webpack-dev-server로 열어 놓은 것 같다) 평소 리액트 개발을 할 때 개발자 도구에서 원본 파일로 디버깅이 되는걸 당연시 했었는데, 사용자 입장에서 원본 파일이 보이니 갑자기 이상한 점이 눈에 띄었다. 파일 출처가 webpack:// 인데, 이게 뭐지?다른 파일들은 모두 URL 주소가 출처로 되어있었다. 그런데 저 리액트 앱 원본 코드들은(심지어 node_modules 폴더도 있다) 출처가 webpack://으로 되어있었다. 도대체 어떻게 가져왔길래 저렇게 표시가 되는지 원리가 궁금해 찾아보게 되었다. 여러가지 시도1. 일반 js 파일처럼 HTTP 요청을 통해 가져 올 것이다개발자 도구에서 일반 js 파일과 똑같이 보이니, 가져오는 방법도 일반 js 파일과 똑같을 것이란 생각이 먼저 들었다. 웹 사이트 내에서 불러오는 모든 리소스는 개발자 도구의 Network 탭에서 확인할 수 있다. 페이지 로딩이 다 끝난 후 확인 해 보니, webpack:// 디렉토리에서 확인할 수 있었던 수많은 js 파일이 단 하나도 없었다. 그래서 일단 webpack://이 뭔지 구글링을 해 보기로 하였다. https://github.com/angular/angular-cli/issues/11058 정확히 나와 똑같은 생각을 한 질문이 있었다. 해당 질문에서 얻은 내용을 정리해 보면 다음과 같다. webpack source map 에 쓰이는 커스텀 프로토콜이다 (나중에 알았지만 커스텀 프로토콜이 아니었다… 이 답변때문에 엄청 헷갈렸다) webpack-dev-server 와 관련이 있다 2. Source Map에 정보가 있을것이다위 답변을 통해 Source Map 과 큰 관련이 있다는 사실을 알 수 있었다. 그래서 우선 Source Map 이 무엇인지 검색해 보았다. 클라이언트측 코드를 결합하거나 최소화하거나 컴파일한 후에도 읽을 수 있고 디버그할 수 있게 합니다.소스 맵을 사용하여 소스 코드를 컴파일된 코드에 매핑합니다 정리하자면, webpack과 같이 원본 코드를 압축, 변형하는 경우 변형된 코드를 원본 소스코드를 보며 디버깅 할 수 있도록 변환된 파일을 원본 파일에 맵핑해 주는 파일이라고 한다. 맵핑할 js 파일 하단에 //# sourceMappingURL=http://example.com/sourcemap.map 과 같이 맵핑 파일의 URL을 넣어주면 자동으로 디버깅시 원본 소스코드를 보여준다고 한다. 위 사진처럼, Source Map detected 란 문구와 함께 맨 아랫줄에 주석으로 source map의 URL이 있는걸 확인할 수 있었다. 해당 URL로 들어가보니, 정신이 혼미해지는 source map 파일을 확인할 수 있었다. 현재 사용되는 소스맵은 스펙은 V3 버전인데, 다음과 같은 구조를 가진다고 한다. 12345678{ version : 3, file: \"out.js\", // source map 을 해줄 컴파일 된 js 파일 sourceRoot : \"\", // 원본 소스파일들 앞에 붙여줄 공통 경로 sources: [\"foo.js\", \"bar.js\"], // output file을 만드는데 쓰인 js 파일들 names: [\"src\", \"maps\", \"are\", \"fun\"], // javascript 안에 있는 함수, 변수 등의 이름 mappings: \"AAgBC,SAAQ,CAAEA\" // base64로 인코딩 된 실제 맵핑 테이블} 위 스펙에 따르면, webpack:///./public/javascripts/dummyl18nResource.js?1e80같은게 실제 파일이 있는 URL이어야 한다. 근데 경로에 . 이 들어가 있질 않나, webpack:// 같은걸로 시작하는 등 일반적인 URL 모양이 아니었다. 그래도 스펙이 그렇다 하니 일단 해당 URL로 접근 해 보았다. 역시나 안됬지만, 이건 뭐 되는게 더 이상했을 것 같다. 3. webpack 프로토콜이 있을것이다우리가 아는 일반적인 URL은 프로토콜://도메인:포트로 생겼다. 일단 webpack://의 생김새가 URL 처럼 생겼고, 실제로 그렇게 쓰여야 하니, 혹시 사이트 내에서 webpack이라는 커스텀 프로토콜을 정의한게 아닌가 생각이 들었다. 요새 웹은 정말 희안한 기능들이 많아서(ex. ws://), 충분히 가능할거라 생각하였다. 그리고 진짜 커스텀 프로토콜을 정의하는 기능이 있긴 있었다!! 하지만 깃허브 webpack, webpack-dev-server 저장소에서 검색을 해 봐도, 딱히 커스텀 프로토콜을 정의하는 부분을 찾을 수 없었다. 4. Source Map을 이용해 원본 소스코드를 다운해 보자개발자 도구에서 다른 사이트 Source Map이 보인다면 원본 소스코드를 다운할수 도 있다는건데, 이를 구현해놓은 코드가 없나 찾아보다 다음 포스팅을 발견했다. Extracting Javascript From SourceMaps 이분이 딱 내가 원하는 코드를 만들어서 github에 공개까지 해 놓으셨다 (denandz/sourcemapper) 그런데 Source Map 스펙에 따르면 분명 원본 파일을 다운받으려면 sources에 포함된 파일 하나당 한번의 HTTP 요청을 해야하는데, 위 소스코드에는 source map 파일을 받아오는 최초 한번의 HTTP 요청을 제외하고는 HTTP 요청이 없었다. 도대체 그럼 어떻게 원본 파일을 가져오는지 소스코드를 한번 다 읽어 보았다. 12345type sourceMap struct { Version int `json:\"version\"` Sources []string `json:\"sources\"` SourcesContent []string `json:\"sourcesContent\"`} 위 구조체가 sourceMap을 저장하는 구조체인데, sourcesContent 라는 처음보는 속성이 있었다. 구글링 해 보니, Source Map Revision 3 Proposal을 참고하라는 StackOverflow 게시글을 하나 찾을 수 있었다. 2019년 2월 19일에 추가된 스펙이었다. (그럼 그 이전에는 어떻게 소스맵을 제공했을까?) 하지만 스펙문서 설명이 너무 부실해서 저 내용만 봐서는 저게 정확히 무슨 기능인지 알기 어려웠다. 링크를 찾은 StackOverflow 게시글에 따르면, An optional list of source content, useful when the “source” can’t be hosted 아… 그러니까 선택적으로 Source Map 안에 Source Content, 즉 원본 소스코드를 넣을 수 있다는 말이었다… 원본 코드를 싹다 가지고 있어서인지, 저 소스맵 파일 하나의 용량이 20 메가바이트였다… 결론webpack:// 은 프로토콜이나 URL이 아니고, 그냥 웹팩이 임의로 파일 이름에 붙인 접두사 같은 것 이었다. 그리고 sources에 있는 파일 이름과 sourcesContent 에 있는 소스코드 내용이 순서대로 매칭되고, 실제 파일 내용을 sourcesContent에서 가져오더라도 sources 에 있는 파일 URL로부터 가져온것 처럼 개발자 도구에 표시가 되는 것이었다. 글로 정리하니 얼마 안되는 양이지만, 이걸 알아내는데 하루가 걸렸다. 소스맵이 W3C 표준은 아니라고 하는데, 왜 아닌지 알 것 같은 경험이었다😅","link":"/2019/10/21/20191021-what-is-webpack-path/"},{"title":"Node.js 에서 request 한글 깨짐 문제","text":"Node.js 에서 request 모듈을 사용하여 학교 홈페이지를 크롤링 하는 도중 한글이 깨지는 문제가 발생하였다. 사진1. 한글 깨짐 현상 한국인으로서 담담하게 받아들일 수 있는 현상이다. 확인해보니, Node.js는 UTF-8을 기본 인코딩으로 사용하는데 학교 홈페이지는 EUC-KR을 사용해서 글자가 깨지는 것 같았다. 사진2. 웹페이지 인코딩 확인 그래서 iconv 라이브러리를 이용해 EUC-KR 디코딩을 하게 해 주었는데, 이번엔 다른 문자로 글자가 깨졌다. 사진3. EUC-KR 처리 후 한글 깨짐 현상 원인그런데 이 占쏙옙 이라는 글자, 낯설지가 않은 사람들이 많을것이다… 문제를 해결하기에 앞서 왜 한글이 깨지면 저렇게 占쏙옙 이 미친듯이 반복되는지 궁금해 검색 해 보았다. 사진4. 출처 : https://namu.wiki/w/占쏙옙 정리하자면 다음과 같다. EUC-KR로 표현된 데이터가 UTF-8 인코딩으로 저장된다. 이때 UTF-8 범위를 벗어나 표현될 수 없는 문자는 모두 “표현 불가” 문자, 즉 � 로 치환된다. (사진 1) 이를 다시 EUC-KR로 취급하여 UTF-8로 변환하려 하면, 占쏙옙 이 된다. (사진 2) 이때문에 EUC-KR을 잘못 다루면 占쏙옙 파티를 볼 수 있게 되는 것이었다. 내가 겪은 문제는 아마 request 모듈에서 EUC-KR을 제대로 처리하지 않고 바로 UTF-8로 저장을 해서, 이미 � 으로 다 치환이 된 상태에서 EUC-KR 디코딩을 시도한게 원인인 것 같았다. 해결방법해결방법은 간단하다. request 모듈이 문자열 인코딩 처리를 안하게 해주면 된다. (즉 위의 1, 2번이 발생하지 않게 하면 된다) 12345678request({ url:\"http://icampus.ac.kr\" // 원하는 url값을 입력 ,encoding: null //해당 값을 null로 해주어야 제대로 iconv가 제대로 decode 해준다. } ,(err, res, body) =&gt; { // 생략 }}) 참고 : http://b1ix.net/322 야! 잘된다","link":"/2019/10/25/20191025-nodejs-request-encoding/"},{"title":"img 태그와 부모 태그의 높이가 왜 다를까?","text":"블로그에 URL 미리보기 기능을 만들던 도중 img 태그와 부모 태그의 높이가 다른 버그가 발생하였다. 빨간 부분 만큼 높이 차이가 발생 해당 HTML과 CSS는 대략 다음과 같다 html1234567891011&lt;div&gt; &lt;div class=\"og-image\"&gt; &lt;a&gt; &lt;img src=\"~~\"&gt; &lt;/a&gt; &lt;/div&gt; &lt;div&gt; &lt;!-- 웹사이트 요약 텍스트가 들어가는 부분 --&gt; &lt;/div&gt;&lt;div&gt; css1234567.og-image { background: red;}img { height: 120px;} 하지만 이상하게도 og-image 와 img 의 높이가 일치하지 않았다. 위는 비슷하게 구현해 본 코드이다.코드만 보면 img와 og-image의 높이가 같을 것 같지만, 실제 result를 보면 높이가 다르다. img 태그의 사이즈 (596.33 x 200) div.og-image 태그의 사이즈 (596.33 x 206) img를 a로 감싸서 그런가 a 태그를 제거해 보았지만, 여전히 오차가 있었다.혹시나 해서 og-image 의 높이를 직접 120px로 고정해 보니 img와 높이가 일치하긴 했다.하지만 responsive design을 적용 할 계획이라 높이를 고정시키지 않고 해결 할 필요가 있었다. 개발자 도구를 켜놓고 height, flex, max-height 등등 의심이 가는 원인을 다 건드려 보다, display옵션을 바꿔보던 중 버그가 해결되었다. 어떻게 해결 되었나 보니, img 태그의 display 값을 block 으로 바꾸니 해결되었던 것이었다. 문제를 해결한 JSFiddle 마치며img 태그의 display 속성 기본 값은 inline-block 이라고 한다 (그래서 width, height 값을 줄 수 있다고 한다). 근데 웃긴건 그렇다고 해서 다른 inline-block 속성을 준 태그에서 저런 문제가 발생하지는 않는다.(아마 img 태그는 좀 특별한 케이스의 inline-block인것 같다.) img 태그에서만 저런 문제가 발생하는것 같은데, 섬세한 관심이 필요한 친구인 것 같다. 기회가 되면 아래 링크의 img 태그 스펙을 자세히 살펴봐야 할것 같다. &lt;img&gt;: The Image Embed elementThe HTML img element embeds an image into the document. 사실 URL 미리보기가 잘 작동하는거 자랑할려고 괜히 한번 링크를 걸어보았다. 😏👍🏻","link":"/2019/10/28/20191028-html-img-parent-height/"},{"title":"Rollup & Svelte 에서 PurgeCSS 사용하기","text":"외주 프로젝트용 Web Component 개발에 UI 라이브러리를 사용하니, 빌드된 컴포넌트 사이즈가 너무 큰 문제가 발생해 PurgeCSS를 이용해 최적화를 해 보기로 하였다. 개발 환경은 다음과 같았다. Front-End Framework : Svelte Module Bundler : Rollup.js UI Library : Bulma 디자인을 전달받기 전이라 우선 UI 라이브러리를 사용하여 개발을 진행하였다.Rollup은 자바스크립트 번들러이기 때문에, 기본적으로는 진짜 자바스크립트 파일밖에 번들링을 못한다.따라서 .svelte, .css 파일을 번들링 하기 위해서는 적절한 플러그인을 적용해 주어야 한다. 1. Rollup Plugin 추가rollup.config.js123456789101112131415import svelte from 'rollup-plugin-svelte';import postcss from 'rollup-plugin-postcss';// 몇가지 Plugin을 더 사용했지만, 생략export default { input: 'src/index.js', output: [ { file: `public/${pkg.module}`, 'format': 'es' }, { file: `public/${pkg.main}`, 'format': 'umd', name } ], plugins: [ svelte(), postcss() ]} rollup-plugin-svelte 를 통해 .svelte 파일을 로드하고, rollup-plugin-postcss 를 통해 .css 파일을 로드할 수 있게 설정하였다. 이제 svelte 파일의 script 부분에서 Bulma의 css 파일를 import 할 수 있다. 2. svelte 컴포넌트에서 css 파일 import 하기component.svelte12345&lt;script&gt; import 'bulma/css/bulma.css'; //생략&lt;/script&gt;// Svelte HTML 부분 이렇게 해서 만들어진 컴포넌트는 아래처럼 생겼다. Svelte와 Bulma를 이용한 스마트폰 검색 Web Component 그런데 문제가 생겼다. css 파일을 import 하면 이를 string으로 바꿔서 통째로 번들링 해버리기 때문에, 쓰지 않는 속성까지 다 포함되어 용량이 너무 컸던 것이었다. Web Component 치고는 무거운 결과물 요즘 웹사이트 하나 webpack으로 빌드하면 기본이 몇 MB 이니, 260kb 정도면 작다 생각할 수 있지만, 이건 웹 컴포넌트로 쓸꺼라 최대한 줄일 필요가 있었다. 그래서 사용하지 않는 css 속성을 제거해준다는 PurgeCSS라는 툴을 사용해 보기로 했다. (이름이 ㅎㄷㄷ 하다. CSS 숙청…😦) PurgeCSS우선 PostCSS는 Webpack, Gulp, Grunt, Rollup 등 그냥 아무데나 다 갖다 쓸 수있고, 심지어 그냥 Standalone 으로도 쓸 수 있는 툴이다. 나는 빌드환경을 Rollup으로 잡아놓았기 때문에, 공식 사이트에 나와있는 Rollup 가이드를 확인해 보았다. updated 2020.04.11 : 현재는 페이지가 삭제되었다 PurgeCSS With Rollup 이게 끝이다. 그냥 저 페이지에 저거밖에 없었다… 정보가 너무 빈약해서 Configuration을 살펴보았다. Options1234567891011{ content: Array&lt;string | RawContent&gt;, css: Array&lt;string | RawContent&gt;, extractors?: Array&lt;ExtractorsObj&gt;, whitelist?: Array&lt;string&gt;, whitelistPatterns?: Array&lt;RegExp&gt;, whitelistPatternsChildren?: Array&lt;RegExp&gt;, keyframes?: boolean, fontFace?: boolean, rejected?: boolean} 중요한 부분만 보자면 다음과 같았다. content : css 사용 여부를 확인할 파일 (ex. html, js) css : 숙청할 css 파일 extractors : content에서 css selector를 추출해 주는 친구 whitelist : 사용되지 않더라도 숙청하지 않을 css selector 목록 With Rollup 가이드를 보면, content로 html 파일을 사용하고 있다. .svelte 파일도 사용 가능한지 공식 문서를 확인해 보았다. PurgeCSS provides a default extractor that is working with all types of filesbut can be limited and not fit exactly the type of files or css framework that you are using. 확인해 보니 Default Extractor로도 모든 파일이 다 된다고 한다(우와 개쩐다). 하지만 좀더 정확히 하려면 Custom Extractor를 만들어 쓰라고 한다. langbamit/purgecss-from-html 이라는 누가 만들어 놓은 Svelte용 Extractor가 있었다. 결론부터 말하면 이거 안써도 똑같이 잘 되서 처음엔 썼지만 마지막 단계에서는 그냥 안쓰기로 하였다. 이제 PurgeCSS를 Rollup에 적용해 보았다. rollup.config.js1234567891011121314151617181920212223242526import svelte from 'rollup-plugin-svelte';import postcss from 'rollup-plugin-postcss';import purgecss from 'rollup-plugin-purgecss';import PurgeSvelte from \"purgecss-from-svelte\";// 몇가지 Plugin을 더 사용했지만, 생략export default { input: 'src/index.js', output: [ { file: `public/${pkg.module}`, 'format': 'es' }, { file: `public/${pkg.main}`, 'format': 'umd', name } ], plugins: [ svelte(), postcss(), purgecss({ content: [\"./src/**/*.svelte\"], extractors: [ { extractor: PurgeSvelte, extensions: [\"svelte\"] } ] }) ]} 여기서 한방에 되면 재미가 없으니, 바로 오류를 뿜어주는 Rollup… CssSyntaxError 라는 키워드로 구글링을 하다 다음 StackOverflow 게시글을 발견했다 CssSyntaxError (1:1) Unknown word &gt; 1 | // extracted by mini-css-extract-plugin · Issue #358 · webpack-contrib/mini-css-extract-pluginmode: &amp;#39;production&amp;#39;, devtool: &amp;#39;#source-map&amp;#39;, plugins: [ new webpack.DefinePlugin({ &amp;#39;process.env.NODE_ENV&amp;#39;: JSON.strin… you have multiple loader for css please check your configuration css loader를 여러개 설정해서 생기는 에러라고 한다. 그래서 postcss 플러그인을 빼고 purgecss만 남겨보았는데, 또 에러가 발생하면서 안되었다. 좀더 구글링을 하던중, 어느 외국회사 GitLab이 떴다…! (다음에 GitLab 쓸일이 있으면 조심해야겠다…) 운이 좋게도 그곳에서 해답을 얻을 수 있었다. PurgeCSS를 Rollup Plugin이 아니라 PostCSS의 Plugin으로 만들어 놓은게 있었다 (FullHuman/postcss-purgecss). 성공한 Rollup 설정은 다음과 같다. rollup.config.js12345678910111213141516171819202122232425262728293031import svelte from 'rollup-plugin-svelte';import postcss from 'rollup-plugin-postcss';import Purgecss from \"@fullhuman/postcss-purgecss\"import PurgeSvelte from \"purgecss-from-svelte\";// 몇가지 Plugin을 더 사용했지만, 생략const purgeCss = Purgecss({ content: [\"./src/**/*.svelte\"], extractors: [ { extractor: PurgeSvelte, extensions: [\"svelte\"] } ]});export default { input: 'src/index.js', output: [ { file: `public/${pkg.module}`, 'format': 'es' }, { file: `public/${pkg.main}`, 'format': 'umd', name } ], plugins: [ svelte(), postcss({ plugins: [ purgeCss ] }), ]} PurgeCSS 적용한 결과물 File Size 결과는 감동적이었다. 264kb 에서 46kb로 무려 83% 감소하였다…😭 PurgeCSS 적용한 결과물 그런데 위 사진처럼 폰트가 좀 이상하게 나왔다. 확인해 보니 아래 selector가 날라갔다. 아마 Bulma 라이브러리가 폰트를 모든 Element에 적용하기 위해 body 태그에 적용했는데, .svelte 파일 내에서 body태그를 직접적으로 사용하는 부분이 없어서 안쓴다고 판단되 삭제된것같다. `body` selector로 폰트가 적용되어있다 `body` selector가 삭제되었다 그래서 PurgeCSS 의 whitelist에 body를 추가해 주었다. Solutionrollup.config.js123456789101112131415161718192021222324252627import svelte from 'rollup-plugin-svelte';import postcss from 'rollup-plugin-postcss';import Purgecss from \"@fullhuman/postcss-purgecss\"// import PurgeSvelte from \"purgecss-from-svelte\";// purgecss-from-svelte 는 안써도 문제 없다// 몇가지 Plugin을 더 사용했지만, 생략const purgeCss = Purgecss({ content: [\"./src/**/*.svelte\"], whitelist: ['body'] // whitelist 추가});export default { input: 'src/index.js', output: [ { file: `public/${pkg.module}`, 'format': 'es' }, { file: `public/${pkg.main}`, 'format': 'umd', name } ], plugins: [ svelte(), postcss({ plugins: [ purgeCss ] }), ]} 폰트가 성공적으로 잘 적용되었다. 빌드된 모듈 용량은 거의 그대로였다.","link":"/2019/11/09/20191109-purgecss-with-rollup-and-svelte/"},{"title":"Meteor에서 gRPC, DDP 사용하기","text":"Meteor는 Node.js 기반 Fullstack Web Framework이다. 이 글에서는 백엔드에서 프론트엔드 이외의 외부 클라이언트와 통신하는 기능을 추가하는 방법에 대해 이야기해 보고자 한다. Meteor는 기본적으로 웹소켓을 이용해 프론트엔드와 백엔드가 통신할 수 있는 기능을 제공한다. 이 기능을 통해 프론트엔드 개발을 할 때 MongoDB를 마치 서버에서 접근하듯이 손쉽게 다룰 수 있다. 하지만 이번 프로젝트 요구사항에는 프론트엔드, 백엔드가 아닌 제3의 클라이언트가 간단한 DB operation을 할 수 있는 기능이 필요하였다. 간단히 소개하자면, 실행이 오랫동안 걸리는 반복 수행 작업을 쉘 스크립트로 돌릴 때, 어느정도 진행되었는지를 Meteor 서버에게 알려주고 웹 프론트엔드로 모니터링 할 수 있는 서비스이다. 여러 조사 끝에 정리한 후보는 다음과 같다. RESTful API gRPC Distributed Data Protocol (DDP) 결론부터 말하면, 최종적으로 gRPC를 사용하기로 결정하였다. 아래 부터는 각각이 무엇이고, 어떤 장단점이 있는지 설명한다. RESTful API쉽게말해 HTTP GET, POST 요청등을 이용해 클라이언트와 서버가 소통하는 방법이다. 가장 흔하게 사용되는 방법이라 먼저 떠올랐지만, 다음과 같은 이유로 선정하지 않았다. Meteor에서 지향하는 방법이 아니다. Meteor는 Fullstack 프레임 워크라, 애초에 백엔드와 프론트엔드의 통합이 잘 이루어져 있는데, 특이하게 REST API가 아니라 웹소켓을 사용한다. 따로 REST API서버를 Meteor에 만들 순 있지만, 복잡해 보여 시도하지 않았다. 오버헤드가 클것같다. 실제 측정을 해본것은 아니지만, 아무래도 HTTP 프로토콜 레이어가 들어가니 다른 선택지에 비해 오버헤드가 있을것 같았다. gRPCgRPC는 구글에서 만들고 오픈 소스로 운영 중인 RPC(Remote Procedure Call) 프레임워크이다. 원래 RPC가 성능이 안좋던것을 개선해 지금은 REST API보다도 성능적으로 우세한것 같다.다음과 같은 이유로 선정하였다. 빠르다 grpcurl 이라는 커맨드라인용 툴이 존재한다. (심지어 go로 만들어서 빠르다!) 사용법일반적으로 Node.js에서 gRPC 서버 여는 방법을 따라하였다. (Node.js gRPC Services in Style) 다만 gRPC 서버를 Meteor에서 사용하려만 한가지 제약이 있는데, gRPC 서버에서 Meteor의 DB 함수를 사용하려면 Meteor.bindEnvironment 라는 함수로 래핑 해주어야 한다. 그렇게 복잡하지는 않고 코드 한두줄이 추가되는 정도이다. 자세한 내용은 Meteor code must always run within a Fiber 를 참고하였다. grpc.js12345678910111213141516const bound = Meteor.bindEnvironment((callback) =&gt; {callback();});const newSession = (call, callback) =&gt; { console.log(call.request); bound(() =&gt; { Tasks.insert({ title: call.request.title, createdAt: new Date(), }, (err, res) =&gt; { console.log(err, res); }); callback(null, { /* response data here */ }); });}; Distributed Data Protocol (DDP)공식 소개글 : Introducing DDP Meteor에 gRPC 올리는 방법을 찾아보다 알아낸 기능인데, 아마 이게 뭔지 아는사람은 거의 없을것 같다. Meteor 개발자팀이 만든 프로토콜로, Meteor의 프론트엔드와 백엔드가 웹소켓으로 통신할때 사용하는 프로토콜이다. 재밌는 점은 WebSocket 이라는것 자체가 웹 브라우저 밖에서도 쓸 수 있기 때문에, 그점을 이용해 Meteor와 아무상관없는 제3의 클라이언트에서도 미티어 백엔드와 DDP를 통해 통신할수 있다!! 사람들도 이미 DDP를 Remote Procedure Call(RPC)의 한 종류로 취급하고, 실제로 그렇게 쓰는 경우도 있어 보였다. 사실이라면 굳이 또다른 RPC인 gRPC를 도입할 필요가 없어보였다. DDP는 사람들이 다양한 언어에서 라이브러리로 구현해 놓았는데, 4년 전이 마지막 업데이트인게 대부분이었다… Meteor 와 다른 언어/플랫폼과의 통신 수단인 DDP 플랫폼 별 DDP Clients 그래서 Node.js로 구현한 DDP 클라이언트와 gRPC와 성능 비교를 해 보았다. MongoDB document를 10개 만드는데 걸리는 시간을 비교하였다. 121.69s user 0.41s system 42% cpu 4.954 total # DDP (node.js)0.10s user 0.07s system 82% cpu 0.204 total # gRPC (go) 결과는 DDP의 처참한 패배였다. DDP가 Node.js에서 돌아가긴 했지만, 감안하더라도 25배의 성능 차이는 용납할 수 없었다. DiscussionClient 입장에서의 실행 시간을 기준으로만 gRPC를 선택하였지만, 사실 Meteor 백엔드에 gRPC를 위한 서버가 하나 더 생기는 것이기 때문에 이 방법이 최선이라는 보장은 없다.또한 DDP 클라이언트는 node.js로 실험했기 때문에, 매번 스크립트 파싱, DDP 라이브러리 로드 등등 오버헤드가 커서 성능 차이가 더 심각한 것일수도 있다. 나는 어차피 요청 클라이언트를 쉘 스크립트 안에서 매번 다시 실행할것이기 때문에 위 실험 환경이 유의미 하지만, 지속적으로 돌아가는 클라이언트나 node.js가 아닌 다른 환경에서 실행하면 DDP의 성능이 gRPC에 비해 그렇게 나쁘지 않을수도 있다 생각한다. Conclusion구글이 만든 gRPC를 구글이 만든 go로 구현한게 최고인것 같다. 구글 만세 😊 References npm.js/ddp Node.js gRPC Services in Style Meteor code must always run within a Fiber grpcurl Introducing DDP Meteor 와 다른 언어/플랫폼과의 통신 수단인 DDP 플랫폼 별 DDP Clients","link":"/2020/04/11/20200411-meteor-grpc-ddp/"},{"title":"러스트 시작해보기","text":"요새 러스트가 핫하다고 해서 한번 배워보았고, 알고리즘 문제를 풀어보며 C++과 느낌이 어떻게 다른지 비교 해 보았다. Why Rust?요즘들어 파이썬이나 Node.js로 작업을 많이 하고 있었는데, 용량이 수십 MB, 수 GB 하는 데이터를 처리하다 보니 속도가 느린게 너무 심하게 체감이 되었다. 스크립팅 언어의 퍼포먼스 한계를 느끼면서, 네이티브로 컴파일되는 언어도 하나 배워야 할 필요성을 느끼게 되었다. 그래서 요즘 핫한 Go와 Rust 둘중에 고민하였는데, 결론부터 말하면 둘을 비교하는것 자체가 적절하지 않고, 어느 하나가 더 좋다고 할 수 없다고 느겼다. 이 둘이 목표로 하는 방향성 자체가 다르기 때문이다. Rust는 더 나은 C++을 지향하고, Go는 더 나은 Java를 지향한다고 한다(내 체감상으로는 Java보다는 Python과 비교하는게 더 맞는것 같다). 물론 단순 퍼포먼스만 보자면 Rust가 평균적으로 살~~짝 좋다고 한다 (Golang vs Rust 퍼포먼스 벤치마킹 썰). Rust와 Go를 비교하는건 다음에 해보기로 하고, 이 글에서는 Rust와 C++로 알고리즘 문제를 풀어보며 내가 느낀 차이점을 비교해 보려 한다. 알고리즘 문제 풀어보기알고리즘 문제는 백준에 올라와있는 간단한 BFS문제를 선택하였다(2178. 미로탐색). 둘의 코드가 최대한 비슷한 모양이 되도록 하기 위해 C++17으로 작성하였다. 나는 C++도 많이 안 다루어 보았고, Rust도 간단한 문법만 배우고 써본것이라 둘 다 적절한 코딩 스타일과 기능을 사용하지 않았을 수 있으니 감안하고 보면 좋을 것 같다… C++와 Rust로 작성한 코드(왼쪽: C++, 오른쪽: Rust) 약간의 줄바꿈 조절이 있긴 했지만, 둘 다 50줄 정도의 코드가 나왔고, 예상보다 C++과 Rust의 코드 모습이 그렇게 크게 다르진 않았다. 우선은 C++부터 살펴보고, 이를 Rust로 그대로 옮기면서 Rust 컴파일러가 뱉은 에러를 하나씩 살펴보며 Rust가 어떻게 Memory Safety를 제공하는지 생각해 보았다. C++ 풀이 위 코드는 테스트 케이스는 통과하긴 하는데, 백준에 제출하면 오답으로 뜬다. Rust 풀이 다음은 Rust로 코드를 옮기면서 겪은 어려움과 느낀점이다. 인풋 받는게 불편함scanf 같은 함수가 없어서 한줄을 받고 직접 파싱을 해야 했고, string이 int로 인덱싱이 안되서 as_bytes함수로 바이트 어레이로 바꾼 다음 한 바이트씩 뽑아야 했다. 다른건 몰라도 인풋받는거 때문에 알고리즘 문제를 푸는데는 C++이 나은것 같다. 메모리 접근에 대해 매우 깐깐함38, 39번 줄을 보면 visited, field 배열의 인덱스로 사용되는 nx, ny를 usize로 캐스팅 해서 쓰는것을 볼 수 있다. 이는 Rust가 강제하는 사항으로, 배열의 인덱스는 무조건 usize 타입이어야 한다. 또한 범위를 초과하는 인덱스로 접근하면 바로 크래시가 나며 프로그램을 종료한다고 한다. 알고리즘 문제라는 특수한 상황에서는 그럴일이 거의 없겠지만, 실제 프로그램 개발시에는 저런 문제로 메모리 접근 취약점이 발생할 수 있는데, C++로 풀때는 아무생각없이 signed integer를 인덱스로 사용했는데 Rust가 강제로 잡아주니 뭔가 나쁜 습관을 교정받는 느낌이었다. 값의 소유와 대여위 코드에서도 나와있는데, 1if (0..n).contains(&amp;nx) &amp;&amp; (0..m).contains(&amp;ny){ 부분에서 contains함수가 nx, ny 값을 변경하는거도 아닌데 레퍼런스로 값을 받고 있다. 이는 contains함수가 파라미터로 받은 값을 소유하게 되는것이 아니라 단순히 잠깐 빌려쓰기 때문이다. 또한 nx, ny는 immutable 하기 때문에, contains 함수는 값을 소유하지도, 변경하지도 않을 것이란것을 컴파일러가 알 수 있다. 소유권이라는 개념을 새로운 키워드 없이 레퍼런스라는 개념 위에 얹어 간단하게 구현한게 아주 신기했다. 그래도 C++과 Rust의 비슷한 점 일단 둘 다 표준 라이브러리가 Snake Case로 이름을 짓는다. 그리고 두 코드 모두 STL에 포함된 Deque를 썼는데, 둘의 메소드 이름이 거의 똑같았다 (e.g., push_back). 포인터와 레퍼런스 개념도 C++와 Rust가 거의 유사한것 같다. 다른점은 Rust에서 포인터(*)는 Unsafe 취급을 받고, 레퍼런스는 사용에 제약(소유, 대여)이 많다는 정도? C++17과 비교하면 문법적인 차원에서 큰 차이는 없는것 같다. Memory Safety가 잘 보장될까?정말 저런 단순한 아이디어로 Memory Safety가 보장될까? 라고 생각할 수 있다. 그런데 사실 위에 작성한 C++, Rust 코드는 Rust부터 작성하고 C++로 번역한 것인데, 신기한것은 Rust는 정답이라 뜨는데 C++는 몇몇 인풋에 대해 답은 뜨는데 메모리 에러가 뜬다. C++로 작성할때 일부러 메모리 접근에 큰 신경을 안쓰긴 했지만, 실제로 Rust 컴파일러가 이러한 문제점을 잘 잡아주는 것 같다. 흥미로우신 분들은 위 C++코드에서 메모리 문제가 발생하는 원인을 알아보아도 좋을 것 같다. Summary내가 느낀 Rust는 한마디로 정의하면 Memory safety가 추가된 Modern C++ 인것 같다. 언어차원의 Tuple, Range 지원 등을 제외하면 C++17에서도 람다함수, destructuring 등등 많은 현대적인 언어 기능을 지원하고 있어 문법적인 측변에서 차이는 그렇게 크지 않은것 같았다. 하지만 Memory Safety 관련해서는 깐깐한 과외선생님을 옆에 두고 코딩하는 느낌을 받았으며, 확실히 Rust 컴파일러가 제공하는 Memory Safety 교정을 받으면 안전한 프로그램을 만드는데 큰 도움이 될 것 같다고 느꼈다. 근데 너무 깐깐해서 크고 중요한 프로젝트가 아니면 그냥 Go 쓰는게 나을것 같다 😏. References Golang vs Rust 퍼포먼스 벤치마킹 썰 2178. 미로탐색","link":"/2020/07/24/20200724-starting-rust/"},{"title":"클로저에서 캡처된 변수는 어디 저장될까?","text":"클로저(Closure)는 자신이 생성(선언)된 외부 환경을 기억(Capture)하는 함수이다. 이 글에서는 Python, Javascript, Go가 각각 어떻게 이를 구현하는지를 알아보았다. 클로저에 대한 자세한 설명은 여기[1]를 참조하고 생략하고, 이 글에서는 클로저의 기능중 클로저 함수 외부에 선언된 변수를 접근하는 Capturing이 여러 언어에서 어떻게 구현되는지를 살펴보고자 한다. 여러 언어에서의 Closure우선 클로저를 지원하려면 언어 차원에서 함수를 일급 객체(First-class object)로 취급을 해야한다. 물론 함수가 일급 객체가 아닌 언어에서 클로저를 지원하는 경우도 있다. 그 예로 자바의 경우 Java8 부터 람다 함수가 도입되고 Closure를 사용할 수 있지만, 언어차원에서의 지원이 아니라 함수 하나당 그때그때 익명 클래스를 하나씩 생성하는 꼼수를 사용하며, final로 선언된 변수만 참조할수 있는 등 제약이 많아 완벽하다 할 수는 없다. 그래서 주로 동적 언어에서 잘 구현되어 있는데, 구글에 클로저를 검색하면 대부분 자바스크립트 언어에 대한 글이 나온다.아마 자바스크립트가 클로저를 제일 아름답고 직관적으로 쓸 수 있어서 그런것 같다. 특히 ES6부터 생긴 화살표 함수를 통한 currying[2]은 아주 아름다운 클로저를 만들어 낸다. 아래 코드는 자바스크립트에서 커링을 통해 클로저를 만들어내는 예시이다. closure.js1234567const makeAdder = (add) =&gt; (to) =&gt; add + to;const add2 = makeAdder(2);const add5 = makeAdder(5);console.log(add2(10)); // 12console.log(add5(10)); // 15 파이썬의 경우 언어차원에서 지원을 하긴 하는데… 파이썬으로 만들면 클로저가 뭔가 조잡해 보인다. 람다함수가 무조건 하나의 statement이어야 하는 제약때문에 한계도 많고, 무엇보다 안이쁘다. 위 코드를 파이썬으로 만들면 아래와 같다. closure.py1234567make_adder = lambda add: lambda to: add + toadd2 = make_adder(2)add5 = make_adder(5)print(add2(10)) # 12print(add5(10)) # 15 그런데 의외로 컴파일 언어인 Go에서 함수가 일급 객체이며, 클로저를 지원한다고 한다. 각각의 언어는 어떻게 캡처(Capture)한 변수를 저장할까? JavascriptJavascript 관련한 내용은 워낙 좋은 자료가 많은데, Toast에서 게시된 이 글[3]이 제일 잘 설명하고 있는 것 같으니, 꼭 한번 보길 권장한다. 자바스크립트는 함수가 선언되어 있는 Lexical Scope를 기억하며, 이 Scope 객체 안에 함수 내에 선언된 변수들이 저장된다. 용어가 무서운데, Dynamic Scope와 비교하면 이해하기 쉽다. Lexical Scope : 소스코드상의 위치를 기준으로 context 판단 Dynamic Scope : 실행 상태를 기준으로 context 판단 함수가 여러겹 겹쳐있을 수 있으니, Lexical Scope는 체인 형태로 함수가 내부적으로 가지고 있게 된다. 함수 내에서 변수에 접근하면, 제일 가까운 Scope부터 해당 변수가 선언되어 있는지 찾으며 마지막은 Global scope를 탐색한다. Javascript에서 Lexical Scope를 통해 변수를 찾는 과정 클로저에서 Capturing이 발생하면, 클로저가 속해있던 Lexical Scope를 클로저를 만들어 낸 함수가 종료된 후에도 체인에서 없애지 않고 유지한다. 이때 클로저에서 사용되지 않는 변수는 가비지 컬렉터에 의해 수거되어 Scope 객체에서 사라진다. Python파이썬에서는 함수도 객체(Object)이다. 파이썬은 인터프리터가 코드를 해석하면서 클로저에 Capture된다고 판단한 외부 변수는 함수 객체 내의 __closure__ 라는 특별한 변수에 저장한다[4]. 객체에 어떤 속성들이 있는지 확인하는 매직 메소드인 __dir__을 통해 클로저에는 __closure__라는 변수가 존재함을 확인할 수 있다. closure2.py1234567891011121314def outer_func(): msg = 'Hi' print('outer_func local variables :', locals()) def inner_func(): inner_var = 'Bye' print(msg) print('inner_func local variables :', locals()) return inner_funcmy_func = outer_func()my_func()print(my_func.__dir__()) 위 코드를 실행하면 아래와 같은 결과가 나온다. 1234outer_func local variables : {&apos;msg&apos;: &apos;HI&apos;}HIinner_func local variables : {&apos;inner_var&apos;: &apos;Bye&apos;, &apos;msg&apos;: &apos;HI&apos;}[&apos;__repr__&apos;, &apos;__call__&apos;, &apos;__get__&apos;, &apos;__new__&apos;, &apos;__closure__&apos;, &apos;__doc__&apos;, &apos;__globals__&apos;, &apos;__module__&apos;, &apos;__code__&apos;, &apos;__defaults__&apos;, &apos;__kwdefaults__&apos;, &apos;__annotations__&apos;, &apos;__dict__&apos;, &apos;__name__&apos;, &apos;__qualname__&apos;, &apos;__hash__&apos;, &apos;__str__&apos;, &apos;__getattribute__&apos;, &apos;__setattr__&apos;, &apos;__delattr__&apos;, &apos;__lt__&apos;, &apos;__le__&apos;, &apos;__eq__&apos;, &apos;__ne__&apos;, &apos;__gt__&apos;, &apos;__ge__&apos;, &apos;__init__&apos;, &apos;__reduce_ex__&apos;, &apos;__reduce__&apos;, &apos;__subclasshook__&apos;, &apos;__init_subclass__&apos;, &apos;__format__&apos;, &apos;__sizeof__&apos;, &apos;__dir__&apos;, &apos;__class__&apos;] 신기한점은 locals라는 로컬 변수를 출력하는 함수를 통해 확인해보면, 캡처된 변수도 일반 지역변수처럼 보인다는 것이다. 프로그래머의 편의성을 위한것으로 보이며, 실제로 저장은 __closure__에 된다. GoGo는 컴파일 언어답게, 이 문제를 컴파일러가 해결한다. 컴파일 하면서 선언된 함수 밖에서도 사용된다고 판단한 변수는 Stack이 아니라 Heap에 저장하게 한다고 한다. 신기한게 이 외에도 new를 통해 동적 할당한 메모리도 함수 내에서만 쓰이면 Stack에 할당하는 듯 힙 사용 최적화를 하는듯 하다[5]. 어떤 경우에 스택에 선언되고, 어떤 경우에 힙에 선언되는지는 여기[5] 잘 정리되어 있으니, 꼭 한번 보길 추천한다. Summary위 내용을 표로 정리하면 다음과 같다. 언어 저장위치 방식 Javascript Lexical Scope 체인 유지 캡처되지 않는 변수는 스코프 객체에서 제거 Python 함수 Object 내 __closure__ 필드 캡처되는 변수만 추가 Go Heap 메모리 컴파일 타임에 저장위치 결정 결국은 다 Heap에 저장한다. References1.클로저(closure)의 개념 ↩2.Currying in Javascript ↩3.자바스크립트의 스코프와 클로저 ↩4.파이썬 - 클로저 (Closure) ↩5.golang - 스택과 힙에 대해 ↩","link":"/2020/07/27/20200727-closure-and-free-vars/"},{"title":"모던 CLI 툴 추천 리스트","text":"리눅스나 macOS에서 터미널을 사용하다 보면 CLI 명령어를 자주 사용하게 된다. 대부분의 강의나 포스팅에서는 초창기부터 있던 전통적인 CLI 툴 위주로 알려주는데, 요즘에는 더 이쁘고 빠르고 편한 툴들이 많이 나와서 괜찮은 것들을 한번 정리해 보았다. 아래 나열된 툴들 대부분은 기존 CLI 명령어를 대체, 개선하고자 만들어졌다. 그래서 제공하는 기능과 목표는 비슷하지만, 조금씩 다른 명령어 인터페이스를 제공한다. 또한 모두 공통적으로 colorized output을 제공하여 시각적 만족도가 높다. exa https://github.com/ogham/exa 현대판 ls 컬러 하이라이트, tree 모드 등을 제공한다 나는 exa를 ls로 alias해서 사용하는데, 아주 만족스럽다 😎 ripgrep https://github.com/BurntSushi/ripgrep 현대판 grep grep보다 훨씬 빠르다고 하다 regex 친화적인 검색 (Rust 내장 regex 엔진 사용) fd https://github.com/sharkdp/fd 현대판 find find보다 더 빠르다고 하다 jq https://github.com/stedolan/jq 커맨드라인 JSON 프로세싱 툴 JSON path를 통해 입력된 JSON에서 특정 필드를 추출하는 등의 작업 가능 curl과 pipe하여 REST api 리스폰스를 파싱하기 좋음 속도와 표현력이 좋다 fx https://github.com/antonmedv/fx jq와 비슷한 JSON 프로세싱 툴 jq는 C언어로 작성되었는데, fx는 node.js라서 좀 더 느리다 대신 nodejs 3rd-party 라이브러리를 쓸 수 있어 jq보다 확장성이 좋다 기본 기능만 봐서는 jq가 더 좋아보임 interactive mode, streaming 등 지원 httpie https://github.com/httpie/httpie 현대판 curl 쉽고 사람 친화적인 사용성을 지향한다 curlie https://github.com/rs/curlie curl 인터페이스로 wrapping 해놓은 httpie 아웃풋은 httpie지만 인풋, 옵션 등 사용법이 curl과 동일 bat https://github.com/sharkdp/bat 현대판 cat 줄번호 표시, syntax highlight 등등 nnn https://github.com/jarun/nnn 터미널 파일 매니저 (터미널에서 쓰는 탐색기라고 보면 된다) 보통 mv, cp, mkdir 등등 명령어를 개별로 써야하는데 nnn 속에서 단축키로 여러 작업 가능 ranger https://github.com/ranger/ranger nnn이랑 비슷, 터미널 파일 매니저 좀 더 기능이 많고 복잡하다 python으로 구현되어있어 좀 느리다 tldr https://github.com/tldr-pages/tldr 현대판 man … 보다는 특정 명령어로 자주 사용하는 예제만 보여주는 man Community driven이라 사람들이 추가한 커맨드에 대한 정보만 나온다 fzf https://github.com/junegunn/fzf fuzzy finder라고, 검색한 문자열로 매칭될 수 있는 모든 파일, 커맨드 히스토리 등을 찾아줌 부분 매칭, 전체 매칭 등 아주 강력하다 원래 터미널에는 없는 기능인데, 진짜 사기적으로 편하다. 다른건 몰라도 이건 꼭!! 설치하는것을 추천 특히 커맨드 히스토리 찾는 기능이 정말 편하다 여기서 소개한 툴 중 유일하게 한국인이 만들었다 🇰🇷","link":"/2020/09/10/20200910-modern-cli-tools/"},{"title":"VSCode에서 원격으로 gdb 디버깅하기","text":"macOS 환경에서 비주얼 스튜디오 코드를 통해 원격으로 리눅스 환경의 C/C++ 프로그램을 디버깅 해보자. Remote Debug를 통해 Remote Development 보다 가볍게 원격 환경에서 디버깅을 할 수 있다. PrefaceVisual Studio Code(VSCode)는 Remote Development[1] 플러그인을 통해 원격 머신에 연결해 마치 로컬 머신에서 VSCode를 사용하는 것 같은 인터페이스를 제공한다.이를 통해서 윈도우나 맥에서도 Docker나 SSH를 통해 리눅스에서와 똑같은 개발 환경을 경험할 수 있게 되었다. 올해 Remote Development가 업데이트 되면서 MacOS를 원격 환경으로 하여 사용할수도 있게 되면서, 집에 맥북을 두고 다니면서 어디에서든지 VSCode만 깔아서 내 맥북에서와 똑같은 개발 환경을 유지할 수 있게 되어 나도 아주 유용하게 사용하고 있다. 그런데 Remote Development 플러그인은 Remote OS에 VS Code Server라는 꽤 무거운 데몬 프로세스를 실행해야 한다는 단점이 있다. 그림 1. Remote Development Architecture 내가 사용중인 개발 환경은 Local OS(맥북)에 C 소스코드가 있고, 소스코드 폴더를 Docker 인스턴스인 Ubuntu에 마운트 해서 빌드와 실행만 Remote OS 내에서 할 수 있는 구조였기 때문에, 모든 개발 과정이 아닌 디버깅 과정만 Remote OS에서 진행할 수 있으면 충분하였다. 내가 고려한 원격으로 C/C++을 디버깅 하는 방법은 크게 두가지가 있다. CLion으로 원격 디버깅[2] 장점 : C/C++ 특화 IDE다 보니 디버깅 인터페이스가 좋지 않을까 싶다. 단점 : 이미 VSCode로 개발중인데 IDE가 하나 추가되고, CLion에서 프로젝트도 새로 생성해야 한다. 프로젝트에 C/C++ 언어만 사용중인게 아니라 다양한 언어 지원이 중요하였다. VSCode로 원격 디버깅 장점 : 이미 사용중이라 gdb를 원격으로 연결만 하면 된다. 단점 : 디버깅 인터페이스가 CLion보다는 하급인것 같다. 디버깅에 뭐 거창한 기능을 바라는게 아니라 그냥 쓰고있던 VSCode에서 원격으로 gdb 연결하는 방식을 선택하였다. 말이 원격으로 gdb 연겷하는 것이지, 개발자 입장에서는 로컬 IDE에서 디버깅 하는것처럼 VSCode에서 브레이크 포인트도 걸 수 있고 다 할 수 있다. 내부적으로 gdb를 쓰는지는 설정할 때 빼고는 크게 체감은 안된다. 설정 환경 Local machine macOS Catalina 10.15.6 GNU gdb (GDB) 9.2 VSCode 1.47.3 Remote machine Ubuntu 20.04 LTS (Docker instance) docker desktop community 2.3.0.4 GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1 VSCode Remote Debugger 연결하기맥북 VSCode에서 Remote OS에 gdb를 연결하기 위해서는 크게 세가지 단계가 필요하다. macOS에 gdb 설치 linux에 gdbserver 설치 macOS에 VSCode 설정 여러 포스팅을 참고 하였는데[3][4][5], 안되는 부분들이 몇 있어서 조금씩 수정하면서 진행하였다. macOS에 gdb 설치VSCode는 gdb가 내장되어 있지 않기 때문에, 따로 설치를 해야한다. macOS에는 기본적으로 gdb가 없는것 같은데, 나는 homebrew를 통해 최신버전을 설치를 해 주었다. 1$ brew install gdb 참고: macOS에서 linux 바이너리를 디버깅 해야하기 때문에 다른 포스팅들을 보면 brew install gdb --with-all-targets 를 통해 모든 아키텍쳐 정보를 포함하게 gdb를 설치하라 하는데, 나는 저렇게 하면 --with-all-targets 플래그에서 에러가 났다. 그래서 플래그 없이 설치했는데 잘 되는거 보니 최신 버전에는 기본적으로 모든 아키텍쳐 데이터가 포함되나 보다. 이때 설치 이후에도 두가지를 더 신경써야 한다. 1. 기본 설치되어 있는 gdb 링크 업데이트brew install gdb 이후 출력하는 메세지를 잘 보면, 이미 /usr/local/bin/gdb 파일이 존재하는 경우 brew는 새로 설치된걸로 덮어쓰기를 하지 않는다. 그래서 직접 이를 overwrite 해주어야 한다. 1$ brew link --overwrite gdb 2. gdb에 codesign 적용디버깅은 커널 권한을 사용하기 때문에, macOS에서는 프로그램에 서명을 해야 정상적으로 사용할 수 있다. 이 과정이 어렵진 않은데 좀 길기때문에, 기회가 되면 다음에 따로 포스팅을 하도록 하고 중요한 부분만 짚고 넘어가도록 하자. self-signed 인증서 발급 후 gdb 바이너리 파일 서명 https://sourceware.org/gdb/wiki/PermissionsDarwin[6] .gdbinit 설정 macOS 10.12 (Sierra) 부터는 gdb 7.12.1 이상을 사용해야 하고, 아래 옵션을 gdb를 실행하고 입력해 적용시켜 줘야 한다. set startup-with-shell off 또는 홈 디렉토리에 .gdbinit 파일을 만들어서 해당 옵션을 적어 놓으면 자동으로 gdb를 실행할때마다 적용한다.1set startup-with-shell off 2번까지 완료했으면 hello world 를 만들어서 디버깅이 되나 확인해보도록 하자. linux에 gdbserver 설치Linux에서는 원격 디버깅을 열어주는 gdbserver*를 설치해야 하는데, *gdb 패키지에 내장되어 있기 때문에 gdb가 깔려있으면 따로 설치할 필요가 없고, 안깔려 있으면 다음 명령어를 통해 설치해 주면 된다. 1$ sudo apt install gdb 그다음 디버깅을 할 바이너리 파일을 gdbserver로 열어놓으면 된다. 1$ gdbserver :9091 ./path/to/binary arg1 arg2 ... 당연한 얘기지만 :9091에서 포트는 꼭 9091일 필요는 없으며, command line arguments가 있으면 바이너리 파일을 명시한 이후 순서대로 적어주면 된다. 다음과 같은 메세지가 뜨면 성공! 12Process ./path/to/binary created; pid = 171Listening on port 9091 그리고 디버깅 세션이 끝나면 gdbserver가 꺼지기 때문에, VSCode에서 디버깅을 실행하기 전 매번 다시 위 명령어를 실행해야 한다. (계속 켜놓는 옵션이 있는지는 모르겠다) macOS VSCode에서 디버깅 설정소스코드 파일을 보면서 디버깅을 하기 위해서는 당연한 얘기이지만, 소스코드가 있어야한다 (로컬에도 있어야 한다). 바이너리 파일은 로컬, 리모트에 둘다 있어야 하는데 소스코드는 로컬에만 있으면 되는것 같다. 우선 나는 Local OS에 있는 소스코드 폴더를 Docker에 마운트 시킨 상태이기 때문에, 모든 파일이 공유되고 있는 상황이다. 클라우드 서버로 원격 디버깅을 하는 상황 등에서는 rsync, sshfs, nfs 등을 사용해 파일을 동기화 시키는 방법을 주로 쓴다고 하는데, 내생각에는 실시간 파일 동기화는 필요 없기 때문에 미리 옮겨놓는 정도면 충분할 것 같다. 아래 그림에서 1번을 누르면 디버깅 메뉴가 뜬다. 2번을 누르면 launch.json 파일이 생성되고, 편집기로 열어준다. 그림 2. Debug Configuration 추가 configurations 필드에는 어레이가 들어가는데, 다음과 같은 json 오브젝트를 추가해 주자. launch.json12345678910111213141516171819202122232425{ \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"My Remote Debug\", \"type\": \"cppdbg\", \"request\": \"launch\", \"program\": \"${workspaceRoot}/path/to/bin\", \"miDebuggerServerAddress\": \"localhost:9091\", \"stopAtEntry\": false, \"cwd\": \"${workspaceRoot}/path/to/src\", \"environment\": [], \"externalConsole\": true, \"linux\": { \"MIMode\": \"gdb\" }, \"osx\": { \"MIMode\": \"gdb\" }, \"windows\": { \"MIMode\": \"gdb\" } } ]} 이때, program, miDebuggerServerAddress, cwd 세개의 필드가 중요하다. program local에 있는 바이너리 파일의 경로를 써주어야 한다. miDebuggerServerAddress 원격 서버의 IP 주소와 gdbserver를 실행항때 사용한 포트를 적어주어야 한다. 나는 docker 포트 매핑을 하였기 때문에 localhost를 IP로 사용하였다. cwd 이 경로를 기준으로 소스코드 파일을 찾으며, 컴파일 할때의 상대경로를 기준으로 한다. 쉽게 생각해서 컴파일을 수행한 cwd와 일치시켜주면 된다. 디버깅 시작하기gdbserver를 시작하고, VSCode에서 추가한 설정으로 디버깅을 시작하면 gdbserver 에서 다음과 같은 메세지가 뜨면 성공이다. 123Process ./path/to/binary created; pid = 178Listening on port 9091Remote debugging from host 172.17.0.1 그림 3. Debugging 시작 성공! 이제부터는 평소 IDE에서 디버깅 하던대로 하면 된다 😉 References1.VS Code Remote Development ↩2.Remote Debug via GDB/gdbserver Of CLion With Docker ↩3.How to Debug Programs on Remote Server using GDBServer Example ↩4.Remote gdb from MacOS X to Linux with C++ STL pretty-printing ↩5.Remote debugging of C/C++ code with Visual Studio Code ↩6.PermissionsDarwin ↩","link":"/2020/08/10/20200810-vscode-remote-gdb/"}],"tags":[{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"node.js","slug":"node-js","link":"/tags/node-js/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"rollup","slug":"rollup","link":"/tags/rollup/"},{"name":"svelte","slug":"svelte","link":"/tags/svelte/"},{"name":"meteor","slug":"meteor","link":"/tags/meteor/"},{"name":"gRPC","slug":"gRPC","link":"/tags/gRPC/"},{"name":"Rust","slug":"Rust","link":"/tags/Rust/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"Go","slug":"Go","link":"/tags/Go/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"},{"name":"cli","slug":"cli","link":"/tags/cli/"},{"name":"gdb","slug":"gdb","link":"/tags/gdb/"},{"name":"debug","slug":"debug","link":"/tags/debug/"},{"name":"vscode","slug":"vscode","link":"/tags/vscode/"}],"categories":[{"name":"Development","slug":"Development","link":"/categories/Development/"},{"name":"Web","slug":"Development/Web","link":"/categories/Development/Web/"},{"name":"Programming Language","slug":"Programming-Language","link":"/categories/Programming-Language/"},{"name":"Node.js","slug":"Development/Node-js","link":"/categories/Development/Node-js/"},{"name":"Tools","slug":"Development/Tools","link":"/categories/Development/Tools/"}]}